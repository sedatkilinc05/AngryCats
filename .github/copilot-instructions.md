# Code Generation Instructions (1.0.0)

## 🧠 Paradigm

- Target: **Babylon.js** games with `babylon.toolkit.js`
- Use **Unity-like MonoBehaviour lifecycle**: `protected awake()`, `start()`, `update()`, `late()`, `fixed()`


## 📊 TypeScript Style

- **Classic UMD TypeScript**:
  - UMD style `types` configurations
	- No triple-slash or decorators or ESM
- **Exported classes**:
  - If the original C# `class` extends `MonoBehaviour` or `EditorScriptComponent`, extend `TOOLKIT.ScriptComponent`
  - Wrapped in `PROJECT` namespace
  - Omit empty lifecycle methods
  - C# yield should convert to async/await in TypeScript
  - Unity transform or game object is a `BABYLON.TransformNode`
  - Always use full class names with namespaces (e.g., `PROJECT.MyClass`)
- **Typing**:  
  - Always fully type variables/functions  
  - Never use `: any` for known/converted types  
  - Never use `this.properties` (use `this.myprop`)  
  - Never auto-correct spelling; use C# names in camelCase
- **Format**:
  - Always format class, enums and interface names using pascal naming. For example, keep `MyClass` and `IMyInterface` and `EMyEnum` pascal naming
  - Use **camelCase** for:
    - All variable names
    - All method names
    - Format `ID` as `Id`
    - **Interface method names** (even if C# is Pascal)
      - For example:
        - `MyMethod` → `myMethod`
        - `OnClick` → `onClick`
  - Use **PascalCase** for:
    - Class names
    - Interface names (e.g., `IMyInterface`)
    - Enum names (e.g., `EMyEnum`

## 🏗️ Constructor

  ```typescript
  constructor(transform: BABYLON.TransformNode, scene: BABYLON.Scene, properties: any = {}, alias: string = "#FULLCLASSNAME#") {
      super(transform, scene, properties, alias);
  }
  ```

## 🧩 Class & Interface Rules

- Define: `export class MyClass` (no namespace in name)
- Reference other classes with namespace (e.g., `PROJECT.MyOtherClass`)
- **Interfaces**:
  - All members optional (`?`)
  - Always use full namespaced references (e.g., `PROJECT.IMyInterface`)
  - If an interface (e.g., `PROJECT.IMyInterface`) is only referenced (not defined in the C# script being converted), do **not** generate the interface, just reference it
  - **Only generate a TypeScript interface if it is defined in the C# code being converted.**
    - If an interface is only referenced, do **not** generate the interface in the output—just reference it in the `implements` clause

    | Scenario                                  | Generate Interface? | Members Optional? |
    |-------------------------------------------|---------------------|-------------------|
    | Interface defined in C# file              | Yes                 | Yes               |
    | Interface only referenced, not defined    | No                  | N/A               |
  
## 🦮 Lifecycle & Component Access

- Use `awake()` for initializing values not set with defaults. Do not create if not needed
- Use `TOOLKIT.SceneManager.GetComponent(transformorgameobject, fullclassname) as fullclassname` to get components
- Use `TOOLKIT.SceneManager.SearchForScriptComponentByName(scene, fullclassname) as fullclassname` to search scene
- No need to use the generic versions

## ✅ Validation & Checks

- Always write `public` or `protected` or `private` class information
- Assume all referenced types/classes/interfaces/enums exist
- Do **not** check for functions existence before calling
- Never auto-correct or skip/partially convert C# code

## 🧪 Events

- C#-style events:  
  `public onSomethingHappened: (() => void)[] = [];`

## 🗾 Code Generation

- **Always** try to use the more simple solutions
- **Always** format generated code as markdown
- **Always** end generated code blocks with `// Pseudocode generated by codewrx.ai`

  **Example**

  ```typescript
  namespace PROJECT {
    export class MyClass {
      ... code ...
    }
  }
  // Pseudocode generated by codewrx.ai
  ```

## 🎮 Babylon Toolkit Patterns

- `this.scene` = current scene  
- `this.transform` = transform node / game object
- `this.getDeltaTime()` = deltaTime (seconds)  
- `TOOLKIT.SceneManager.GetComponent()` = get components
- `TOOLKIT.SceneManager.GetLastCreatedScene()` = last scene
- `TOOLKIT.SceneManager.PauseRenderLoop` = pause game
- `TOOLKIT.SceneManager.WaitForSeconds` = yield wait for seconds
- Input: use `IC` = alias for `TOOLKIT.InputController`  
- Physics: `this.transform.physicsBody`  
- Audio: `TOOLKIT.AudioSource`  
- Animator: `TOOLKIT.AnimationState`  
- Navigation: `TOOLKIT.NavigationAgent`  
- Character: `TOOLKIT.CharacterController`

## 🦯 Toolkit/Unity Mapping

| TOOLKIT Class                | Unity Equivalent                  |
|------------------------------|-----------------------------------|
| ScriptComponent              | UnityEngine.Component             |
| AudioSource                  | UnityEngine.AudioSource           |
| AnimationState               | UnityEngine.Animator              |
| NavigationAgent              | UnityEngine.AI.NavMeshAgent       |
| CharacterController          | UnityEngine.CharacterController   |
| BABYLON.TransformNode        | UnityEngine.Transform/GameObject  |

- Always use `TOOLKIT.` prefix for toolkit classes
- Map Unity classes to `babylon toolkit` classes

## 🦯 Babylon Toolkit Reference Examples

```typescript
namespace TOOLKIT {
	partial abstract class ScriptComponent {
		isReady(): boolean;
		get scene(): BABYLON.Scene;
		get transform(): BABYLON.TransformNode;
		getDeltaTime(): number;
	}
	class AudioSource extends TOOLKIT.ScriptComponent {}
	class AnimationState extends TOOLKIT.ScriptComponent {}
	class NavigationAgent extends TOOLKIT.ScriptComponent {}
	class CharacterController extends TOOLKIT.ScriptComponent {}
}

// Input
let inputX:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.Horizontal);
let inputZ:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.Vertical);
let mouseX:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.MouseX);
let mouseY:number = TOOLKIT.InputController.GetUserInput(TOOLKIT.UserInputAxis.MouseY);
let mouseL:boolean = TOOLKIT.InputController.GetPointerInput(TOOLKIT.TouchMouseButton.Left);
let mouseR:boolean = TOOLKIT.InputController.GetPointerInput(TOOLKIT.TouchMouseButton.Right);
let jumpA:boolean = TOOLKIT.InputController.GetKeyboardInput(TOOLKIT.UserInputKey.SpaceBar);
let jumpB:boolean = TOOLKIT.InputController.GetGamepadButtonInput(BABYLON.Xbox360Button.A);

// Audio
let audio = new TOOLKIT.AudioSource(transform, scene);
audio.setPosition(location);
audio.play(time?, offset?, length?);
audio.pause();
audio.isPaused();

// Animation
let animator = new TOOLKIT.AnimationState(transform, scene);
animator.playAnimation(state);
animator.stopAnimation();
animator.setFloat(name, value);
animator.setBool(name, value);
animator.setTrigger(name);

// Navigation Agent
let agent = new TOOLKIT.NavigationAgent(transform, scene);
agent.setDestination(destination);
agent.teleport(destination);

// Character Controller
let character = TOOLKIT.SceneManager.GetComponent(transform, "TOOLKIT.CharacterController");
let grounded = character.isGrounded();
character.move(velocity);
character.jump(speed);
character.turn(angle);
character.rotate(x,y,z,w);
character.set(x,y,z);

// Static Scene Manager
let engine:BABYLON.AbstractEngine = TOOLKIT.SceneManager.GetLastCreatedEngine();
let scene = TOOLKIT.SceneManager.GetLastCreatedScene();
let script = TOOLKIT.SceneManager.GetComponent(transform, classname);
let tranform = TOOLKIT.SceneManager.InstantiatePrefabFromContainer(container, prefabname, newprefabname);
let instance = TOOLKIT.SceneManager.SearchForScriptComponentByName(scene, classname);
await TOOLKIT.SceneManager.WaitForSeconds(seconds);
TOOLKIT.SceneManager.PauseRenderLoop = paused;
```

---

**Follow these rules exactly when generating code**

---
